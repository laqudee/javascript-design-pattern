# 深入设计模式

## 结构型模式

> 如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效

- 适配器，让接口不兼容的对象能够相互合作
- 桥接模式，将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构
- 组合，可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们
- 装饰，通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为
- 外观，能为程序库、框架或其他复杂类提供一个简单的接口
- 享元模式，摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象
- 代理，能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理

### 适配器模式

- 让接口不兼容的对象能够相互合作

- 适配器：一个特殊的对象，能够转换对象接口，使其能与其他对象进行交互

- 运作方式：
  1. 适配器实现与其中一个现有对象兼容的接口
  2. 现有对象可以使用该接口安全地调用适配器方式
  3. 适配器方法被调用将以另一个对象兼容的格式和顺序将请求传递给改对象

1. 客户端是包含当前程序业务逻辑的类
2. 客户端接口描述了其他类与客户端代码合作时必须遵守的协议
3. 适配器
4. 客户端只需要通过接口与适配器交互即可，无需与具体的适配器类耦合

- 类适配器不需要封装任何对象，因为它同时继承了客户端和服务的行为。

- 实现方式：
  1. 确保至少有两个类的接口不兼容
     1. 一个无法修改的功能性服务类
     2. 一个多个将受益于使用服务类的客户端类
  2. 声明客户端接口，描述客户端如何与服务交互
  3. 创建遵循客户端接口的适配器类
  4. 在适配器类中添加一个成员变量用于保存对于服务对象的引用
  5. 依次实现适配器类客户端接口的所有方法
  6. 客户端必须通过客户端接口使用适配器

- 适配器可以对已有对象的接口进行修改，装饰模式则能在不改变对象接口的前提下强化对象功能
- 适配器能为被封装对象提供不同的接口，代理模式能为对象提供相同的接口，装饰则能为对象提供加强的接口
- 外观模式为现有对象定义了一个新接口，适配器则会试图已有的接口。

### 桥接模式

- 可将一个大类或一系列紧密相关的类拆分为抽象和实现连个独立的层次结构，从而能在开发时分别使用

- 桥接模式通过将继承改为组合的方式来解决多个维度类继承问题
  - 抽取其中一个维度并使之成为独立的类层次，这样就可以在初始类中引入这个新层次的对象，从而使得一个类不必拥有所有的状态和行为

- 将一个类层次转化为多个相关的类层次，避免单个类层次的失控

- 抽象部分：接口，是一些实体的高阶控制层——程序的GUI层
- 实现部分：实现——操作系统的API

- 桥接模式的结构：
  1. 抽象部分，提供高层控制逻辑，依赖于完成底层实际工作的实现对象
  2. 实现部分，为所有具体实现声明通用接口
  3. 具体实现
  4. 精确抽象，提供控制逻辑的变体
  5. 客户端

- 桥接模式适合应用场景
  1. 如果想要拆分或重组一个具有多重功能的庞杂类，可以使用桥接模式
  2. 如果希望在几个独立维度上扩展一个类，可使用该模式
  3. 如果需要在运行时切换不同实现方法，可使用桥接模式

- 实现方式：
  1. 明确类中独立的维度。独立的概念可能是：抽象/平台，前端/后端或接口/实现
  2. 了解客户端的业务需求，并在抽象类中定义它们
  3. 确定在所有平台上都可执行的业务
  4. 为所有平台创建实现类
  5. 在抽象类中添加指向实现类的引用成员变量

- 桥接、状态模式、策略模式实际上都是基于组合模式

### 组合模式

- 可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们

- 如果应用的核心模型能用树状结构表示，在应用中使用组合模型才有价值

- 组合模式建议使用一个通用接口来与产品和盒子进行交互，并且在该接口中声明一个计算总价的方法

- 组合模式以递归方式处理对象树中的所有项目

- 组合模式解构
  1. 组件接口描述了树中简单项目和辅助器项目所共有的操作
  2. 叶节点是树的基本结构，不包含子项目
  3. 容器，又名组合，是包含或其他容器等子项目的单位
  4. 客户端，通过接口与所有项目交互

- 适用场景：
  1. 如果需要实现树状对象结构，可以使用组合模式
  2. 如果希望客户端代码以相同方式处理简单和复杂元素，可以使用该模式

- 实现方式：
  1. 确保应用的核心模型能够以树状结构表示。尝试将其分解为简单元素和容器‘
  2. 声明组件接口及其一系列方法
  3. 创建一个叶节点类表示简单元素
  4. 创建容器类表示复杂元素
  5. 最后，在容器中定义添加和删除子元素的方法

- 可以创建复杂组合树时使用生成器模式
- 责任链模式通常和组合模式结合使用
- 可以使用迭代器模式来遍历组合树
- 可以使用访问器模式对整个组合树执行操作
- 可以使用享元模式实现组合树的共享节点来节省内存


### 装饰模式

- 通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为

- 当你需要更改一个对象的行为时，扩展它所属的类
- 使用聚合或组合，而不是继承

- 封装器是装饰模式的别称，封装器是一个能与其他目标对象连接的对象
- 封装器实现了与其封装对象相同的接口

- 装饰模式结构
  1. 部件，声明封装器和被封装对象的公用接口
  2. 具体部件类，是被封装对象所属的类。它定义了基础行为
  3. 基础装饰类，拥有一个指向被封装对象的引用成员变量
  4. 具体装饰类，定义了可动态添加到部件的额外行为
  5. 客户端，可使用多层装饰来封装部件

- 适用场景：
  1. 如果希望在无需修改代码的情况下即可使用对象，且在运行时为对象新增额外的行为
  2. 如果用继承来扩展对象行为的方案难以实现或者根本不可行

- 实现方式：
  1. 确保业务逻辑可用一个基本组件及多个额外可选层次表示
  2. 找出基本组件和可选层次的通用方法。创建一个组件接口并在其阿红声明这些方法
  3. 创建一个具体组件类，并定义其基础行为
  4. 创建装饰基类
  5. 确保所有类实现组件接口
  6. 将装饰基类扩展为具体装饰
  7. 客户端负责创建装饰并将其组合成客户端所需的形式