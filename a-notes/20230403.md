# 深入设计模式

## 结构型设计模式

### 外观模式

- 能为程序库、框架、其他复杂类提供一个简单的接口

- 结构：
  1. 外观提供了一种访问特定子系统功能的便捷方式，其了解如何重定向客户端请求，知晓如何操作一切活动部件
  2. 创建附加外观类可以避免多种不相关的功能污染单一外观，使其变成又一个复杂结构。客户端和其他外观都就可以使用附加外观
  3. 复杂子系统
  4. 客户端，使用外观替代对子系统对象的直接调用

- 适用场景
  1. 如果需要一个指向复杂子系统的直接接口，且接口的功能有限，则可以使用外观模式
  2. 如果需要将子系统组织为多层结构，可以使用外观模式

- 实现方式
  1. 考虑能否在现有子系统的基础上提供一个更简单的接口。如果该接口能让客户端代码独立于众多子系统类
  2. 在一个新的外观类中声明并实现该接口。外观应将客户端代码的调用重定向到子系统中的相应对象处。如果客户端没有子系统进行初始化，也没有后续声明周期进行管理，那么外观必须完成此类工作
  3. 如果要充分发挥这一模式的优势，必须确保所有客户端仅通过外观与子系统进行交互
  4. 如果外观过于臃肿，可以考虑将其部分行为抽取为一个新的专用外观类

- 外观模式为现有对象定义一个新街口，适配器模式则会视图运用已有的接口。适配器通常只封装一个对象，外观通常会作为整个对象子系统上
- 当只需要对客户端隐藏子系统创建对象的方式时，可以使用抽象工厂模式来替代外观
- 享元模式展示了如何生成大量的小型对象；外观则展示了如何用一个对象来代替整个子系统

- 外观 vs. 中介者模式
  1. 外观为子系统中的所有对象定义了一个简单接口，但不提供任何新功能。子系统本身不会意识到外观的存在。子系统中的对象可以直接进行交流
  2. 中介者将系统中的组件的沟通行为中心化。个组件只知道中介对象，无法直接相互交流

- 外观类通常可以转换为单例模式类

- 外观与代理模式的相似之处在于他们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循统一接口，使得自己和服务对象可以互换

### 享元模式

- 缓存、Cache、 Flyweight

- 摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，可以在有限的内存容量中载入更多对象

- 对象的常量数据通常被称为内在状态，位于对象中，其他对象只能读取但不能修改其数值。
- 而对象的其他状态常常能被其他对象“从外部”改变，因此被称为外在状态

- 享元模式建议不再对象中存储外在状态，而是将其传递给依赖于它的一个特殊方法。程序只在对象中保存内在状态，以方便在不同场景下进行重用。
- 这些对象的区别仅在于其内在状态（与外在状态相比，内在状态的变体要少很多），因此所需的对象数量会大大消减

- 更好的解决方案是创建独立的情景类来存储外在状态和堆对享元对象的引用。

- 一个享元大对象会被上千个情境小对象复用， 因此无需再重复存储数千个大对象的数据

- 享元与不变性
  - 由于享元对象可在不同的情景中使用，必须确保其状态不能被修改。享元类的状态只能由构造函数的参数进行一次性初始化，它不能对其他对象公开其设置器或公有成员变量

- 享元工厂
  - 创建一个工厂方法来管理已有享元对象的缓存池
  - 工厂方法从客户端处接收目标享元对象的内在状态作为参数， 如果它能在缓存池中找到所需享元， 则将其返回给客户端； 如果没有找到， 它就会新建一个享元， 并将其添加到缓存池中

- 结构
  1. 享元模式只是一种优化
  2. 享元类包含原始对象中部分能在多个对象中共享的状态
  3. 情景类包含原始对象中各不相同的外在状态
  4. 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 
  5. 客户端，负责计算或存储享元的外在状态
  6. 享元工厂，会对已有享元的缓存池进行管理

- 适合场景
  1. 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式

- 实现方式
  1. 将需要改写为享元的类成员变量拆分为两个部分：
    - 内在状态：包含不变的、可在许多对象中重复使用的数据的成员变量
    - 外在状态：包含每个对象各自不同的情景数据的成员变量
  2. 保留类中表示内在状态的成员变量，其属性为不可修改。在构造函数中获得初始数值
  3. 找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量
  4. 有选择地创建工厂类来管理享元缓存池
  5. 客户端必须存储和计算外在状态的数值，因为只有这样才能调用享元对象的方法

- 可以使用享元模式实现组合模式树的共享叶节点以节省内存
- 享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统

### 代理模式

- 能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进一下处理

- 代理模式建议新建一个与原服务对象接口相同的代理类，然后更新应用以将代理对象传递给所有原始对象客户端
- 代理类接收到客户端请求后会创建实际的服务对象，并将所有工作委派给它

- 代理模式结构
  1. 服务接口Service Interface声明了服务接口。代理必须遵循该接口才能伪装成服务对象
  2. 服务Service类提供了一些实用的业务逻辑
  3. 代理类，包含一个指向服务对象的引用成员
  4. 客户端，能通过同一接口与服务或代理进行交互

- 适应场景：
  1. 延迟初始化（虚拟代理）
  2. 访问控制（保护代理）
  3. 本地执行远程服务（远程代理）
  4. 记录日志请求（日志记录代理）
  5. 缓存请求结果（缓存代理）
  6. 智能引用

- 实现方式
  1. 如果没有现成的服务接口，就需要创建一个接口来实现代理和服务对象的可交换性
  2. 创建代理类，其中必须包含一个存储指向服务的引用的成员变量
  3. 根据需求实现代理方法
  4. 可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务
  5. 可以考虑为服务对象实现延迟初始化

## 行为模式

- 行为模式负责对象间的高效沟通和职责委派

- 责任链，允许将请求沿着处理者链进行发送。收到请求后，每个处理者均可以对请求进行处理，或将其传递给链上的下一个处理者
- 命令，可将请求转换为一个包含与请求相关的所有信息的独立对象
- 迭代器，能在不暴露集合底层表现形式的情况下遍历集合中所有的元素
- 中介者，能减少对象之间混乱无序的依赖关系。该模式会限制对象之间的的直接交互，迫使通过一个中介者对象进行合作
- 备忘录，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态
- 观察者，发布订阅模式，vue
- 状态，能在一个对象的内部状态变化时改变其行为，使其看上去像改变了自身所属的类一样
- 策略，定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换
- 模板方法，在超类中定义一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤
- 访问者，将算法与其作用的对象隔离开来

### 责任链模式

- 职责链模式、命令链、CoR、Chain of Command

- 责任链会将特定行为转换为被称为处理者的独立对象

- 处理者可以决定不再沿着链传递请求，这可高效地取消后续处理步骤

- 每个具体处理者仅关心下一个包含execute方法对的处理者。

- 结构
  1. 处理者，声明了所有具体处理者的通用接口
  2. 基础处理者，可选类
  3. 具体处理者，包含处理请求的实际代码
  4. 客户端，根据程序逻辑一次性或者动态地生成链

- 责任链适合场景
  1. 当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知
  2. 当必须顺序执行多个处理者时
  3. 如果所需处理者及其顺序必须在运行时进行改变

- 责任链、命令模式、中介模式、观察者模式：
  1. 责任链按照顺序将请求动态传递给一系列的潜在接受者
  2. 命令在发送者和请求者之间建立单向连接
  3. 中介清除了发送者与请求者之间的直接连接
  4. 观察者允许接受者动态地订阅或取消接受请求
