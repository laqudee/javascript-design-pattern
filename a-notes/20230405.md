# 深入设计模式

## 行为模式

### 迭代器模式

- 能在不暴露集合底层表现形式的情况下遍历集合中所有元素

- 将集合的遍历行为抽取为单独的迭代器对象

- 多个迭代器可以在相互独立的情况下同时访问集合

- 迭代器通常会提供一个获取集合元素的基本方法

- 迭代器模式结构：
  1. 迭代器接口声明了遍历集合所需要的操作：获取下一个元素，获取当前位置和重新开始迭代
  2. 具体迭代器实现遍历集合的的一种特定算法
  3. 集合接口声明一个或多个方法获取与集合兼容的迭代器
  4. 具体集合
  5. 客户端

### 中介者模式

- Intermediary、Controller、Mediator

- 能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使他们通过一个中介者对象进行合作

- 组件仅依赖一个中介者类，无需与多个其他组件相耦合

- 中介者模式结构：
  1. 组件是包含业务逻辑的类
  2. 中介者接口声明了与组件交流的方法，但通常仅包含一个通知方法
  3. 具体中介者封装了多种组件间的关系

- 适合应用场景：
  1. 当一些对象和其他对象紧密耦合以至于难于对其进行修改时
  2. 当组件因过于依赖其他组件而无法在不同应用中复用时，可使用中介模式
  3. 如果为了能在不同情景下服用一些基本行为，导致你需要被迫创建大量组件子类时

- 责任链模式、命令模式、中介模式、观察者模式用于处理请求发送者和接收者之间的不同连接方式：
  1. 责任链按照顺序将请求动态传递给一系列的潜在接受者
  2. 命令在发送者和请求者之间建立单向连接
  3. 中介者清除了发送者和请求者之间的直接连接，强制它们通过一个中介者进行间接沟通
  4. 观察者允许接受者动态地订阅或取消接受请求

### 备忘录模式

- Snapshot、Memento

- 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态

- 备忘录模式将创建状态快照的工作委派给实际状态的拥有者原发器对象

- 备忘录模式结构
  1. 原发器类可以生成自身状态的快照
  2. 备忘录是原发器状态的值对象
  3. 负责人仅知道何时和为何捕捉原发器的状态

- 适合应用场景：
  1. 当需要创建对象状态快照来恢复其之前的的状态时
  2. 当直接访问对象的成员变量、获取器或设置器将导致封装被突破时，可以使用该模式

### 观察者模式

- 事件订阅者、监听者、Event-Subscriber、Observer

- 发布订阅机制

- 观察者模式结构：
  1. 发布者Publisher
  2. 当新事件发生时，发送者会遍历订阅列表并调用每个订阅者对象下的通知对象
  3. 订阅者接口
  4. 具体订阅者
  5. 客户端

- 适合应用场景：
  1. 当一个对象状态的改变需要改变其他对象，或实际对象时事先未知的或动态变化的时
  2.  当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用
