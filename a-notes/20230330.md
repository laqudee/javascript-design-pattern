# 深入设计模式

## 创建型模式

### 生成器模式

- 分步骤创建复杂对象。允许使用相同的创建代码生成不同类型和形式的对象。

- 生成器模式建议将对象构建代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象中

- 主管类可定义创建步骤的执行顺序，而生成器则提供这些步骤的实现

1. 生成器Builder，接口声明在所有类型生成器中通用的产品构造步骤
2. 具体生成器Concrete Builder，提供构造过程的不同实现
3. 产品Products，是最终生成的对象
4. 主管Director类，定义调用构造步骤的顺序
5. 客户端Client，必须将某个生成器与主管类关联

- 生成器模式适合应用场景
  1. 使用生成器模式避免“重叠构造函数”的出现
  2. 当你希望使用代码创建不同形式的产品时，可使用生成器模式
  3. 使用生成器构造组合树或其他复杂对象

- 实现方法：
  1. 清晰地定义通用步骤，确保它们可以制造所有形式的产品
  2. 在基本生成器接口中声明这些步骤
  3. 为每个形式的产品创建具体生成器类，并实现其构造步骤
  4. 考虑创建主管类
  5. 客户端代码会同事创建生成器和主管对象
  6. 只有在所有产品都遵循相同接口的情况下，构造结果可以直接通过主管类获取

- 生成器重点关注如何分步生成复杂对象，在获取产品前执行一些额外构造步骤
- 抽象工厂专门用于生产一系列相关对象，会马上返回产品

- 生成器和桥接模式：主管类负责抽象工作，各种不同的生成器负责实现工作

### 原型模式

- 是一种创建型模式，能够复制已有对象，而又无需依赖它们所属的类

- 原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口，该接口能让你能够克隆对象。同时又无需将代码和对象所属类耦合。

- 支持克隆的对象即为原型

- 运作方式：创建一系列不同类型的对象并以不同的方式对其进行配置。如果所需对象与预先配置的对象相同，那么只需要克隆原型即可，无需新建一个对象

- 基本实现：
  1. 原型接口将对克隆方法进行声明。在绝大数情况下，其中只会有一个名为clone的方法
  2. 具体原型类将实现克隆方法
  3. 客户端可以复制实现了原型接口的任何对象

- 原型注册表的实现

- 适用场景：
  1. 如果需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式
  2. 如果之类的区别仅在于其对象的初始化方式，那么你可以使用该模式来减少子类的数量

- 实现方式：
  1. 创建原型接口，并在其中声明克隆方法。
  2. 原型类必须另行定义一个以该类对象为参数的构造函数。构造函数必须复制参数对象中的所有成员变量值到新建实体中。
  3. 克隆方法通常只有一行代码：使用new运算符调用原型版本的构造函数
  4. 还可以创建一个中心化原型注册表，用来存储常用原型

- 原型可用于保存命令模式的历史记录
- 原型并不是基于继承，因此没有继承的缺点。但原型需要对被复制对象进行复杂的初始化。工厂方法基于继承，不需要初始化

- 抽象工厂、生成器、原型都可以用单例模式来实现

### 单例模式

- 能够保证一个类只有一个实例，并提供一个访问该实例的全局节点

- 单例同时解决了两个问题，所违反了单一职责原则
  1. 保证一个类只有一个实例
  2. 为该实例提供一个全局访问节点

- 解决方案：
  1. 将默认构造函数设为私有，防止其他对象使用单例类的new运算符
  2. 新建一个静态构建方法作为构造函数。该函数偷偷调用私有构造函数来创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象

- 单列类声明了一个名为getInstance()的静态方法来返回其所属类的一个相同实例

- 适用场景
  1. 如果程序中的某个类对于所有客户端自由一个可用的实例，可以使用单例模式
  2. 如果需要更加严格地控制全局变量，可以使用单例模式Vue， Vuex， Vue-Router

- 外观模式类通常可以转换为单例模式
- 享元模式vs.单例
  1. 只会有一个单例实体，但是享元类可以有多个实体，个实体的内在状态也可以不同
  2. 单例对象可以是可变的。享元对象是不可变的