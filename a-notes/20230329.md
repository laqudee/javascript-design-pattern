# 深入设计模式

## 创建型模式

### 抽象工厂模式

- 抽象工厂模式是一种创建型模式，能创建一系列相关的对象，而无需指定其具体类

- 抽象工厂模式建议为系列中的每件产品明确声明接口，然后确保所有产品变体都继承这些接口

- 抽象工厂——包含系列中所有产品构造方法的接口。这些方法返回抽象产品类型

- 抽象工厂接口创建不同的工厂类。每个工厂类只能返回特定类型的产品

- 应用程序会在初始阶段创建具体工厂对象，在此之前，应用程序必须根据配置文件或者环境设定选择工厂类别

- 角色：
  - 抽象工厂 --> 创建各种抽象产品
  - 具体工厂 --> 实现抽象工厂的构建方法。每个具体工厂都对应特定产品变体，且仅创建此种产品变体
  - 抽象产品
  - 具体产品

- 适用场景
  1. 如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者处于对未来扩展性的考虑，不希望代码基于产品的具体类进行构建。
  2. 如果有有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么这种情况下可以考虑使用抽象工厂

- 生成器重点关注如何分布生成复杂对象。抽象工厂专门用于生产一系列相关对象
  - 抽象工厂会马上返回产品；生成器则允许你在获取产品前执行一些额外构造步骤

- 抽象工厂、生成器、原型都可以用单例模式来实现

### 工厂模式比较

- 工厂
- 构建方法：创建对象的方法。每个工厂方法模式的结果都是构建方法
- 静态构建（或工厂）方法：是被声明为static的构建方法。无需创建对象就能在某个类上调用该方法
- 简单工厂：描述了一个类，它拥有一个包含大量条件语句的构建方法，可根据方法的参数来选择对何种产品进行初始化并将其返回
- 工厂方法：是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型
- 抽象工厂：是一种创建型设计模式，能创建一系列相关或相互依赖的对象，而无需指定其具体类

- 工厂是一个含义模糊的术语，表示可以创建一些东西的函数、方法、类等

- 构建方法只是构造函数调用的装饰器

- 当静态构建方法返回一个新对象时，它就成了构建函数的替代品
